package hal.spel.aspect

import com.fasterxml.jackson.databind.ObjectMapper
import com.github.kittinunf.fuel.core.Headers
import com.github.kittinunf.fuel.core.Method
import com.github.kittinunf.fuel.core.extensions.cUrlString
import com.github.kittinunf.fuel.core.requests.RepeatableBody
import hal.spel.Answer
import hal.spel.Link
import io.micronaut.http.HttpStatus
import java.io.PrintWriter
import kotlin.math.min

private val jackson = ObjectMapper()

private var counters = mutableMapOf<String, Int>()
private var relation: String? = null

/**
 * Reports the parts of the request and response as AsciiDoctor tags.
 *
 * Using this class the client application can produce the AsciiDoctor document containing
 * tags for all requests/responses application communicates with the server. Then that tags can be included
 * in a separate AsciiDoctor document built by AsciiDoctor plugin into final documentation including
 * "life" data.
 * Different instances of this class can report on different set of parts related to communication
 * with server. For example
 *
 * @param reporter -- the PrintWriter to print the text of the tag into. Could be File, Console or other Writer
 * @param parts -- the vararg of parts to include as tags
 * @param followed -- the AspectFormatter to link in the chain.
 * The Aspect generated by this Formatter will pass control to the aspect generated by this parameter
 */
class ADocTagFormatter(
    private val reporter: PrintWriter,
    vararg val parts: ReportPart,
    followed: AspectFormatter? = null
) : AspectFormatter(followed) {
    private val aDocTagFormatter = mutableMapOf<ReportPart, Pair<LinkFun?, AnswerFun?>>().also {
        ReportPart.values().forEach { part ->
            it[part] = Pair<LinkFun?, AnswerFun?>({
                preADocTagFormatter[part]?.invoke(this, reporter::println)
            }, {
                postADocTagFormatter[part]?.invoke(it, reporter::println)
            })
        }
    }

    override fun makeAspect(aspect: Aspect?): Aspect {
        return makeReporterAspect(aDocTagFormatter, *parts, aspect = super.makeAspect(aspect))

    }
}

private fun <T> formatTag(tagName: String, obj: T?, reporter: (String) -> Unit) {
    when (obj) {
        is Map<*, *> -> reporter("""
                |#tag::$relation-$tagName-${counters[relation]}[]
                |${
            obj.filterValues { it != null }.map { (key, value) ->
                "$key:\t$value"
            }.joinToString("\n|\t", "\t")
        }
                |#end::$relation-$tagName-${counters[relation]}[]
                """.trimMargin()
        )
        is Collection<*> ->
            reporter(
                """
                |#tag::$relation-$tagName-${counters[relation]}[]
                |${obj.joinToString("\n|\t", "\t")}
                |#end::$relation-$tagName-${counters[relation]}[]
                """.trimMargin()
            )
        else -> reporter(
            "#tag::$relation-$tagName-${counters[relation]}[]"
                    + "\n${obj ?: ""}"
                    + "\n#end::$relation-$tagName-${counters[relation]}[]"
        )
    }
}

/**
 * AsciiDoc preRequest aspect definitions
 *
 * This Map defines the aspect making functions for different parts of [Link] object.
 *
 * The maker for [PRE_PARTS.REL] keeps track of similar requests and assigns unique number to make an AsciiDoc tag unique.
 * If this aspect won't be included in an aspect chain the [null] will be used instead of numbers and all segments
 * of AsciiDoc will have identical tags. It is recommended to always include [PRE_PARTS.REL] aspect even if the
 * corresponding segment won't be used in the final documentation.
 *
 *
 */
private val preADocTagFormatter = mapOf<ReportPart, (Link, (String) -> Unit) -> Unit>(
    ReportPart.REL to { link, reporter ->
        // Assign next available number to make a unique AsciiDoc tag
        relation = link.rel?.apply {
            counters[this] = counters[this]?.let {
                it + 1
            } ?: 1
        }
        formatTag("ref", link.rel, reporter)
    },
    ReportPart.LINK to { link, reporter ->
        formatTag("link", link.toMap(), reporter)
    },
    ReportPart.URI to { link, reporter ->
        formatTag("URI", link.href, reporter)
    },
    ReportPart.NAME to { link, reporter ->
        formatTag("name", link.name, reporter)
    },
    ReportPart.TITLE to { link, reporter ->
        formatTag("title", link.title, reporter)
    },
    ReportPart.TYPE to { link, reporter ->
        formatTag("type", link.type, reporter)
    }
)

/**
 * AsciiDoc postRequest aspect definitions
 *
 * This Map defines the aspect making functions for different parts of [Answer] object.
 *
 */
private val postADocTagFormatter = mapOf<ReportPart, (Answer, (String) -> Unit) -> Unit>(
    ReportPart.URL to { answer, reporter ->
        formatTag("URL", answer.response.url.toString(), reporter)
    },
    ReportPart.CURL to { answer, reporter ->
        formatTag(
            "curl", answer.request.cUrlString()
                .replace(" -H", "\\\n  -H")
                .replace(Regex(" (https?://.*)"), "\\\\\n  \"$1\""), reporter
        )
    },
    ReportPart.HEADERS_OUT to { answer, reporter ->
        formatTag("headerOut", answer.request.headers, reporter)
    },
    ReportPart.COOKIES_OUT to { answer, reporter ->
        formatTag("cookieOut", answer.request["Set-Cookies"], reporter)
    },
    ReportPart.BODY_OUT to { answer, reporter ->
        if (answer.request.method in setOf(
                Method.POST,
                Method.PUT,
                Method.PATCH
            ) && !answer.request.body.isConsumed()
        ) {
            formatTag("bodyOut", {
                if (answer.request.body.isConsumed()) {
                    "Length of the sent Body: ${answer.request.body.length}"
                } else {
                    "Body sent:\n${
                        if (answer.request.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body?.invoke())
                        } else {
                            answer.request.body.asString(null)
                        }
                    }"
                }
            }, reporter)
        } else {
            formatTag("bodyOut", "*** Cannot report body sent out ***", reporter)
        }
    },
    ReportPart.STATUS to { answer, reporter ->
        formatTag("status", "${answer.status.code} (${answer.status})", reporter)
    },
    ReportPart.HEADERS_IN to { answer, reporter ->
        formatTag("headersIn", answer.response.headers, reporter)
    },
    ReportPart.COOKIES_IN to { answer, reporter ->
        formatTag("cookiesIn", answer.response["Cookies"], reporter)
    },
    ReportPart.BODY_IN to { answer, reporter ->
        formatTag(
            "bodyIn",
            "Body received:${
                when (answer.status.code) {
                    HttpStatus.FOUND.code -> "Redirection to: ${answer.response.header("Location").first()}"
                    else ->
                        if (answer.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            "\n${jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body?.invoke())}"
                        } else {
                            val head = min(answer.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                            " (length: ${answer.response.contentLength})\n${
                                String(answer.response.data).substring(
                                    0,
                                    head.toInt()
                                )
                            }"
                        }
                }
            }", reporter
        )
    }
)

/**
 * Factory function to create an aspect function to be called before sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Link as an AsciiDocument tag and @reporter
 * will write that text into the stream, which may be associated with file or console.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePreADocTagAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePreReporterAspect(reporter, preADocTagFormatter, *parts, aspect = aspect)
}

/**
 * Factory function to create an aspect function to be called after sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Answer as an AsciiDocument tag and @reporter
 * will write that text into the stream, which may be associated with file or console.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePostADocTagAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePostReporterAspect(reporter, postADocTagFormatter, *parts, aspect = aspect)
}
