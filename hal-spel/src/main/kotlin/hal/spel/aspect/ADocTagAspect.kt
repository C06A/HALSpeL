package hal.spel.aspect

import com.fasterxml.jackson.databind.ObjectMapper
import com.github.kittinunf.fuel.core.Headers
import com.github.kittinunf.fuel.core.extensions.cUrlString
import com.github.kittinunf.fuel.core.requests.RepeatableBody
import hal.spel.Answer
import hal.spel.Link
import io.micronaut.http.HttpStatus
import java.io.PrintWriter
import kotlin.math.min

private val jackson = ObjectMapper()

private var counters = mutableMapOf<String, Int>()
private var relation: String? = null

/**
 * Reports the parts of the request and response as AsciiDoctor tags.
 *
 * Using this class the client application can produce the AsciiDoctor document containing
 * tags for all requests/responses application communicates with the server. Then that tags can be included
 * in a separate AsciiDoctor document built by AsciiDoctor plugin into final documentation including
 * "life" data.
 * Different instances of this class can report on different set of parts related to communication
 * with server. For example
 *
 * @param reporter -- the PrintWriter to print the text of the tag into. Could be File, Console or other Writer
 * @param parts -- the vararg of parts to include as tags
 * @param followed -- the AspectFormatter to link in the chain.
 * The Aspect generated by this Formatter will pass control to the aspect generated by this parameter
 */
class ADocTagFormatter(private val reporter: PrintWriter, vararg val parts: ReportPart, followed: AspectFormatter? = null): AspectFormatter(followed) {
    private val aDocTagFormatter = mapOf(
            ReportPart.REL to Pair<LinkFun?, AnswerFun?>({
                // Assign next available number to make a unique AsciiDoc tag
                relation = rel?.apply {
                    counters[this] = counters[this]?.let {
                        it + 1
                    } ?: 1
                }
                formatTag("ref", rel)
            }, null),
            ReportPart.LINK to Pair<LinkFun?, AnswerFun?>({
                formatTag("link", toMap())
            }, null),
            ReportPart.URI to Pair<LinkFun?, AnswerFun?>({
                formatTag("URI", href)
            }, null),
            ReportPart.NAME to Pair<LinkFun?, AnswerFun?>({
                formatTag("name", name)
            }, null),
            ReportPart.TITLE to Pair<LinkFun?, AnswerFun?>({
                formatTag("title", title)
            }, null),
            ReportPart.TYPE to Pair<LinkFun?, AnswerFun?>({
                formatTag("type", type)
            }, null),

            ReportPart.URL to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("URL", it.response.url.toString())
            }),
            ReportPart.CURL to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("curl", it.request.cUrlString())
            }),
            ReportPart.HEADERS_OUT to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("headerOut", it.request.headers)
            }),
            ReportPart.COOKIES_OUT to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("cookieOut", it.request["Set-Cookies"])
            }),
            ReportPart.BODY_OUT to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                if (answer.request.body.isConsumed()) {
                    formatTag("bodyOut", "Size: ${answer.request.body.length}")
                } else {
                    answer.request.body.let {
                        if (it is RepeatableBody) {
                            if (it.toByteArray().size > 0) {
                                formatTag("bodyOut", "Size: ${it.toByteArray().size}")
                            } else {
                                formatTag("bodyOut", answer.request.body.asString(null))
                            }
                        } else {
                            formatTag("bodyOut", answer.request.body.asString(null))
                        }
                    }
                }
            }),
            ReportPart.STATUS to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("status", "${it.status.code} (${it.status})")
            }),
            ReportPart.HEADERS_IN to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("headersIn", it.response.headers)
            }),
            ReportPart.COOKIES_IN to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("cookiesIn", it.response["Cookies"])
            }),
            ReportPart.BODY_IN to Pair<LinkFun?, AnswerFun?>(null, {
                formatTag("bodyIn", when (it.status.code) {
                    in (200..299) ->
                        if (it.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            jackson.writerWithDefaultPrettyPrinter().writeValueAsString(it.body)
                        } else {
                            val head = min(it.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                            "(length: ${it.response.contentLength})\n${String(it.response.data).substring(0, head.toInt())}"
                        }
                    HttpStatus.FOUND.code -> "|Redirection to: ${it.response.header("Location").first()}"
                    else -> "${it.body?.toJson()}"
                })
            })
    )

    private fun <T> formatTag(tagName: String, obj: T?) {
        formatTag(tagName, obj, { reporter.println(it) })
    }

    override fun makeAspect(aspect: Aspect?): Aspect {
        return makeReporterAspect(aDocTagFormatter, *parts, aspect = super.makeAspect(aspect))
    }
}

private fun <T> formatTag(tagName: String, obj: T?, reporter: (String) -> Unit) {
    when (obj) {
        is Map<*, *> -> reporter("""
                |#tag::$relation-$tagName-${counters[relation]}[]
                |${obj.filterValues { it != null }.map { (key, value) ->
            "$key:\t$value"
        }.joinToString("\n|\t", "\t")}
                |#end::$relation-$tagName-${counters[relation]}[]
                """.trimMargin())
        is Collection<*> ->
            reporter("""
                |#tag::$relation-$tagName-${counters[relation]}[]
                |${obj.joinToString("\n|\t", "\t")}
                |#end::$relation-$tagName-${counters[relation]}[]
                """.trimMargin())
        else -> reporter("#tag::$relation-$tagName-${counters[relation]}[]"
                + "\n${obj ?: ""}"
                + "\n#end::$relation-$tagName-${counters[relation]}[]"
        )
    }
}

/**
 * AsciiDoc preRequest aspect definitions
 *
 * This Map defines the aspect making functions for different parts of [Link] object.
 *
 * The maker for [PRE_PARTS.REL] keeps track of similar requests and assigns unique number to make an AsciiDoc tag unique.
 * If this aspect won't be included in an aspect chain the [null] will be used instead of numbers and all segments
 * of AsciiDoc will have identical tags. It is recommended to always include [PRE_PARTS.REL] aspect even if the
 * corresponding segment won't be used in the final documentation.
 *
 *
 */
private val preADocTagFormatter = mapOf<ReportPart, (Link, (String) -> Unit) -> Unit>(
        ReportPart.REL to { link, reporter ->
            // Assign next available number to make a unique AsciiDoc tag
            relation = link.rel?.apply {
                counters[this] = counters[this]?.let {
                    it + 1
                } ?: 1
            }
            formatTag("ref", link.rel, reporter)
        },
        ReportPart.LINK to { link, reporter ->
            formatTag("link", link.toMap(), reporter)
        },
        ReportPart.URI to { link, reporter ->
            formatTag("URI", link.href, reporter)
        },
        ReportPart.NAME to { link, reporter ->
            formatTag("name", link.name, reporter)
        },
        ReportPart.TITLE to { link, reporter ->
            formatTag("title", link.title, reporter)
        },
        ReportPart.TYPE to { link, reporter ->
            formatTag("type", link.type, reporter)
        }
)

/**
 * AsciiDoc postRequest aspect definitions
 *
 * This Map defines the aspect making functions for different parts of [Answer] object.
 *
 */
private val postADocTagFormatter = mapOf<ReportPart, (Answer, (String) -> Unit) -> Unit>(
        ReportPart.URL to { answer, reporter ->
            formatTag("URL", answer.response.url.toString(), reporter)
        },
        ReportPart.CURL to { answer, reporter ->
            formatTag("curl", answer.request.cUrlString(), reporter)
        },
        ReportPart.HEADERS_OUT to { answer, reporter ->
            formatTag("headerOut", answer.request.headers, reporter)
        },
        ReportPart.COOKIES_OUT to { answer, reporter ->
            formatTag("cookieOut", answer.request["Set-Cookies"], reporter)
        },
        ReportPart.BODY_OUT to { answer, reporter ->
            if (answer.request.body.isConsumed()) {
                formatTag("bodyOut", "Size: ${answer.request.body.length}", reporter)
            } else {
                answer.request.body.let {
                    if (it is RepeatableBody) {
                        if (it.toByteArray().size > 0) {
                            formatTag("bodyOut", "Size: ${it.toByteArray().size}", reporter)
                        } else {
                            formatTag("bodyOut", answer.request.body.asString(null), reporter)
                        }
                    } else {
                        formatTag("bodyOut", answer.request.body.asString(null), reporter)
                    }
                }
            }
        },
        ReportPart.STATUS to { answer, reporter ->
            formatTag("status", "${answer.status.code} (${answer.status})", reporter)
        },
        ReportPart.HEADERS_IN to { answer, reporter ->
            formatTag("headersIn", answer.response.headers, reporter)
        },
        ReportPart.COOKIES_IN to { answer, reporter ->
            formatTag("cookiesIn", answer.response["Cookies"], reporter)
        },
        ReportPart.BODY_IN to { answer, reporter ->
            formatTag("bodyIn", when (answer.status.code) {
                in (200..299) ->
                    if (answer.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                        jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body)
                    } else {
                        val head = min(answer.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                        "(length: ${answer.response.contentLength})\n${String(answer.response.data).substring(0, head.toInt())}"
                    }
                HttpStatus.FOUND.code -> "|Redirection to: ${answer.response.header("Location").first()}"
                else -> "${answer.body?.toJson()}"
            }, reporter)
        }
)

/**
 * Factory function to create an aspect function to be called before sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Link as an AsciiDocument tag and @reporter
 * will write that text into the stream, which may be associated with file or console.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePreADocTagAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePreReporterAspect(reporter, preADocTagFormatter, *parts, aspect = aspect)
}

/**
 * Factory function to create an aspect function to be called after sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Answer as an AsciiDocument tag and @reporter
 * will write that text into the stream, which may be associated with file or console.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePostADocTagAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePostReporterAspect(reporter, postADocTagFormatter, *parts, aspect = aspect)
}
