package hal.spel.aspect

import com.fasterxml.jackson.databind.ObjectMapper
import com.github.kittinunf.fuel.core.Headers
import com.github.kittinunf.fuel.core.Method
import com.github.kittinunf.fuel.core.extensions.cUrlString
import hal.spel.Answer
import hal.spel.Link
import io.micronaut.http.HttpStatus
import kotlin.math.min

const val UNSTRUCTURED_HEAD_LENGTH = 100L

private val jackson = ObjectMapper()

/**
 * Reports the parts of the request and response in the log.
 *
 * Using this class the client application can log all HTTP requests/responses.
 *
 * Different instances of this class can log at different level their own set of HTTP requests/responses parts.
 *
 * For example:
 * <code>
 *     LoggerFormatter(logger::info, ReportPart.REL, ReportPart.status
 *     , followed = LoggerFormatter(logger::debug, ReportPart.URL, ReportPart.HEADERS_OUT)
 *     )
 * </code>
 *
 * @param reporter -- the simple function to log the logging message.
 * @param parts -- the vararg of parts to include as tags
 * @param followed -- the AspectFormatter to link in the chain.
 * The Aspect generated by this Formatter will pass control to the aspect generated by this parameter
 */
class LoggerFormatter(private val reporter: (String) -> Unit, vararg val parts: ReportPart, followed: AspectFormatter? = null) : AspectFormatter(followed) {
    val loggerFormatter: Map<ReportPart, Pair<LinkFun?, AnswerFun?>> = mapOf(
            ReportPart.REL to Pair<LinkFun?, AnswerFun?>({
                reporter(">>>>> $rel <<<<<")
            }, null),
            ReportPart.LINK to Pair<LinkFun?, AnswerFun?>({
                reporter(if (name.isNullOrBlank()) {
                    "Link href: $href"
                } else {
                    "Link name: $name ($href)"
                })
            }, null),
            ReportPart.URI to Pair<LinkFun?, AnswerFun?>({ reporter("URI: $href") }, null),
            ReportPart.NAME to Pair<LinkFun?, AnswerFun?>({ reporter("Named: $name") }, null),
            ReportPart.TITLE to Pair<LinkFun?, AnswerFun?>({ reporter("Titled: $title") }, null),
            ReportPart.TYPE to Pair<LinkFun?, AnswerFun?>({ reporter("Accept: $type") }, null),
            ReportPart.URL to Pair<LinkFun?, AnswerFun?>(null, { reporter("Resource Location: ${it.response.url}") }),
            ReportPart.CURL to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                if (answer.request.method == Method.GET || answer.request.header(Headers.CONTENT_TYPE).contains("json")) {
                    reporter("$> ${answer.request.cUrlString()}")
                }
            }),
            ReportPart.HEADERS_OUT to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                reporter(
                        "Header sent: ${answer.request.headers.map { (key, value) ->
                            "\t$key:\t${value.joinToString("\n\t\t")}"
                        }.joinToString("\n", "\n")}"
                )
            }),
            ReportPart.COOKIES_OUT to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                reporter("Cookies sent: ${answer.request["Set-Cookies"].joinToString("\n\t", "\n\t")}")
            }),
            ReportPart.BODY_OUT to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                if (answer.request.method in setOf(Method.POST, Method.PUT, Method.PATCH))
                    reporter(
                            if (answer.request.body.isConsumed()) {
                                "Length of the sent Body: ${answer.request.body.length}"
                            } else {
                                "Body sent:\n${answer.request.body}"
                            }
                    )
            }),
            ReportPart.STATUS to Pair<LinkFun?, AnswerFun?>(null, { answer -> reporter("Status: ${answer.status.code} (${answer.status})") }),
            ReportPart.HEADERS_IN to Pair(null, { answer ->
                reporter(
                        "Headers received: ${answer.response.headers.map { (key, value) ->
                            "\t$key:\t${value.joinToString("\n\t\t")}"
                        }.joinToString("\n", "\n")}"
                )
            }),
            ReportPart.COOKIES_IN to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                reporter("Cookies received: ${answer.response["Cookies"].joinToString("\n\t", "\n\t")}")
            }),
            ReportPart.BODY_IN to Pair<LinkFun?, AnswerFun?>(null, { answer ->
                reporter("Body received:${
                when (answer.status.code) {
                    in (200..299) ->
                        if (answer.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            "\n${jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body)}"
                        } else {
                            val head = min(answer.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                            " (length: ${answer.response.contentLength})\n${String(answer.response.data).substring(0, head.toInt())}"
                        }
                    HttpStatus.FOUND.code -> "Redirection to: ${answer.response.header("Location").first()}"
                    else -> "\n${answer.body?.toJson()}"
                }}"
                )
            })
    )

    override fun makeAspect(aspect: Aspect?): Aspect {
        return makeReporterAspect(loggerFormatter, *parts, aspect = super.makeAspect(aspect))
    }
}

private val preLoggerFormatter = mapOf<ReportPart, (Link, (String) -> Unit) -> Unit>(
        ReportPart.REL to { link, reporter ->
            reporter(">>> ${link.rel} <<<")
        },
        ReportPart.LINK to { link, reporter ->
            reporter(if (link.name.isNullOrBlank()) {
                "Link href: ${link.href}"
            } else {
                "Link name: ${link.name} (${link.href})"
            })
        },
        ReportPart.URI to { link, reporter -> reporter("URL: ${link.href}") },
        ReportPart.NAME to { link, reporter -> reporter("Named: ${link.name}") },
        ReportPart.TITLE to { link, reporter -> reporter("Titled: ${link.title}") },
        ReportPart.TYPE to { link, reporter -> reporter("Accept: ${link.type}") }
)

private val postLoggerFormatter = mapOf<ReportPart, (Answer, (String) -> Unit) -> Unit>(
        ReportPart.URL to { answer, reporter -> reporter("Resource Location: ${answer.response.url}") },
        ReportPart.CURL to { answer, reporter ->
            if (answer.request.method == Method.GET || answer.request.header(Headers.CONTENT_TYPE).contains("json")) {
                reporter("$> ${answer.request.cUrlString()}")
            }
        },
        ReportPart.HEADERS_OUT to { answer, reporter ->
            reporter(
                    "Header sent: ${answer.request.headers.map { (key, value) ->
                        "\t$key:\t${value.joinToString("\n\t\t")}"
                    }.joinToString("\n", "\n")}"
            )
        },
        ReportPart.COOKIES_OUT to { answer, reporter ->
            reporter("Cookies sent: ${answer.request["Set-Cookies"].joinToString("\n\t", "\n\t")}")
        },
        ReportPart.BODY_OUT to { answer, reporter ->
            if (answer.request.method in setOf(Method.POST, Method.PUT, Method.PATCH))
                reporter(
                        if (answer.request.body.isConsumed()) {
                            "Length of the sent Body: ${answer.request.body.length}"
                        } else {
                            "Body sent:\n${answer.request.body}"
                        }
                )
        },
        ReportPart.STATUS to { answer, reporter -> reporter("Status: ${answer.status.code} (${answer.status})") },
        ReportPart.HEADERS_IN to { answer, reporter ->
            reporter(
                    "Headers received: ${answer.response.headers.map { (key, value) ->
                        "\t$key:\t${value.joinToString("\n\t\t")}"
                    }.joinToString("\n", "\n")}"
            )
        },
        ReportPart.COOKIES_IN to { answer, reporter ->
            reporter("Cookies received: ${answer.response["Cookies"].joinToString("\n\t", "\n\t")}")
        },
        ReportPart.BODY_IN to { answer, reporter ->
            reporter("Body received:${
            when (answer.status.code) {
                in (200..299) ->
                    if (answer.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                        "\n${jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body)}"
                    } else {
                        val head = min(answer.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                        " (length: ${answer.response.contentLength})\n${String(answer.response.data).substring(0, head.toInt())}"
                    }
                HttpStatus.FOUND.code -> "Redirection to: ${answer.response.header("Location").first()}"
                else -> "\n${answer.body?.toJson()}"
            }}"
            )
        }
)

/**
 * Factory function to create an aspect function to be called before sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Link as an message for logger and @reporter
 * will call logger method with some level to log that message.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePreLoggerAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePreReporterAspect(reporter, preLoggerFormatter, *parts, aspect = aspect)
}

/**
 * Factory function to create an aspect function to be called after sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Answer as an message for logger and @reporter
 * will call logger method with some level to log that message.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePostLoggerAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePostReporterAspect(reporter, postLoggerFormatter, *parts, aspect = aspect)
}
