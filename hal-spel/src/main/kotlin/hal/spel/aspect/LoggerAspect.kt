package hal.spel.aspect

import com.fasterxml.jackson.databind.ObjectMapper
import com.github.kittinunf.fuel.core.Headers
import com.github.kittinunf.fuel.core.Method
import com.github.kittinunf.fuel.core.extensions.cUrlString
import hal.spel.Answer
import hal.spel.Link
import io.micronaut.http.HttpStatus
import kotlin.math.min

const val UNSTRUCTURED_HEAD_LENGTH = 100L

private val jackson = ObjectMapper()

/**
 * Reports the parts of the request and response in the log.
 *
 * Using this class the client application can log all HTTP requests/responses.
 *
 * Different instances of this class can log at different level their own set of HTTP requests/responses parts.
 *
 * For example:
 * <code>
 *     LoggerFormatter(logger::info, ReportPart.REL, ReportPart.status
 *     , followed = LoggerFormatter(logger::debug, ReportPart.URL, ReportPart.HEADERS_OUT)
 *     )
 * </code>
 *
 * @param reporter -- the simple function to log the logging message.
 * @param parts -- the vararg of parts to include as tags
 * @param followed -- the AspectFormatter to link in the chain.
 * The Aspect generated by this Formatter will pass control to the aspect generated by this parameter
 */
class LoggerFormatter(
    private val reporter: (String) -> Unit,
    vararg val parts: ReportPart,
    followed: AspectFormatter? = null
) : AspectFormatter(followed) {
    private val loggerFormatter: Map<ReportPart, Pair<LinkFun?, AnswerFun?>> =
        mutableMapOf<ReportPart, Pair<LinkFun?, AnswerFun?>>().also {
            ReportPart.values().forEach { part ->
                it[part] = Pair<LinkFun?, AnswerFun?>({
                    preLoggerFormatter[part]?.invoke(this, reporter)
                    this
                }, {
                    postLoggerFormatter[part]?.invoke(it, reporter)
                })
            }
        }

    override fun makeAspect(aspect: Aspect?): Aspect {
        return makeReporterAspect(loggerFormatter, *parts, aspect = super.makeAspect(aspect))
    }
}

private val preLoggerFormatter = mapOf<ReportPart, (Link, (String) -> Unit) -> Link>(
    ReportPart.REL to { link, reporter ->
        reporter(">>> ${link.rel} <<<")
        link
    },
    ReportPart.LINK to { link, reporter ->
        reporter(
            if (link.name.isNullOrBlank()) {
                "Link href: ${link.href}"
            } else {
                "Link name: ${link.name} (${link.href})"
            }
        )
        link
    },
    ReportPart.URI to { link, reporter -> reporter("URL: ${link.href}"); link },
    ReportPart.NAME to { link, reporter -> reporter("Named: ${link.name}"); link },
    ReportPart.TITLE to { link, reporter -> reporter("Titled: ${link.title}"); link },
    ReportPart.TYPE to { link, reporter -> reporter("Accept: ${link.type}"); link }
)

private val postLoggerFormatter = mapOf<ReportPart, (Answer, (String) -> Unit) -> Unit>(
    ReportPart.URL to { answer, reporter -> reporter("Resource Location: ${answer.response.url}") },
    ReportPart.CURL to { answer, reporter ->
        if (!(answer.request.method in setOf(
                Method.POST,
                Method.PUT,
                Method.PATCH
            ) && answer.request.body.isConsumed())
        ) {
            reporter("$> ${answer.request.cUrlString()}")
        } else {
            reporter("*** Cannot report curl ***")
        }
    },
    ReportPart.HEADERS_OUT to { answer, reporter ->
        reporter(
            "Header sent: ${
                answer.request.headers.map { (key, value) ->
                    "\t$key:\t${value.joinToString("\n\t\t")}"
                }.joinToString("\n", "\n")
            }"
        )
    },
    ReportPart.COOKIES_OUT to { answer, reporter ->
        reporter("Cookies sent: ${answer.request["Set-Cookies"].joinToString("\n\t", "\n\t")}")
    },
    ReportPart.BODY_OUT to { answer, reporter ->
        if (answer.request.method in setOf(
                Method.POST,
                Method.PUT,
                Method.PATCH
            )
        ) {
            reporter(
                if (answer.request.body.isConsumed()) {
                    "Length of the sent Body: ${answer.request.body.length}"
                } else {
                    "Body sent:\n${
                        if (answer.request.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body?.invoke())
                        } else {
                            answer.request.body.asString(null)
                        }
                    }"
                }
            )
        } else {
            reporter("*** Cannot report body sent ***")
        }
    },
    ReportPart.STATUS to { answer, reporter -> reporter("Status: ${answer.status.code} (${answer.status})") },
    ReportPart.HEADERS_IN to { answer, reporter ->
        reporter(
            "Headers received: ${
                answer.response.headers.map { (key, value) ->
                    "\t$key:\t${value.joinToString("\n\t\t")}"
                }.joinToString("\n", "\n")
            }"
        )
    },
    ReportPart.COOKIES_IN to { answer, reporter ->
        reporter("Cookies received: ${answer.response["Cookies"].joinToString("\n\t", "\n\t")}")
    },
    ReportPart.BODY_IN to { answer, reporter ->
        reporter(
            "Body received:${
                when (answer.status.code) {
                    HttpStatus.FOUND.code -> "Redirection to: ${answer.response.header("Location").first()}"
                    else ->
                        if (answer.response.header(Headers.CONTENT_TYPE).any { it.contains("json") }) {
                            "\n${jackson.writerWithDefaultPrettyPrinter().writeValueAsString(answer.body?.invoke())}"
                        } else {
                            val head = min(answer.response.contentLength, UNSTRUCTURED_HEAD_LENGTH)
                            " (length: ${answer.response.contentLength})\n${
                                String(answer.response.data).substring(
                                    0,
                                    head.toInt()
                                )
                            }"
                        }
                }
            }"
        )
    }
)

/**
 * Factory function to create an aspect function to be called before sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Link as an message for logger and @reporter
 * will call logger method with some level to log that message.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePreLoggerAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePreReporterAspect(reporter, preLoggerFormatter, *parts, aspect = aspect)
}

/**
 * Factory function to create an aspect function to be called after sending HTTP request.
 *
 * The aspect created by this factory will call @reporter function for the string generated by the function in the map.
 * The function in the map formatting the corresponding part of the Answer as an message for logger and @reporter
 * will call logger method with some level to log that message.
 *
 * @param reporter -- function to record the formatted tag String
 * @param parts -- a vararg array of the parts to report on
 * @param aspect -- another aspect to chain to after executing this
 */
fun makePostLoggerAspect(reporter: (String) -> Unit, vararg parts: ReportPart, aspect: Aspect? = null): Aspect {
    return makePostReporterAspect(reporter, postLoggerFormatter, *parts, aspect = aspect)
}
